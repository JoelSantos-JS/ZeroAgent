const ffmpeg = require('fluent-ffmpeg');
const lamejs = require('lamejs');
const fs = require('fs').promises;
const path = require('path');
const logger = require('../utils/logger');

class AudioOptimizer {
  constructor() {
    this.name = 'AudioOptimizer';
    this.tempDir = path.join(__dirname, '../temp');
    this.defaultConfig = {
      speed: 1.5,           // Acelerar para 1.5x (economia de 33% tokens)
      bitrate: '128k',      // Qualidade adequada para voz
      sampleRate: 16000,    // Otimizado para reconhecimento de voz
      format: 'mp3'         // Melhor compress√£o
    };
  }

  // Inicializar otimizador (criar diret√≥rio temp se necess√°rio)
  async initialize() {
    try {
      await fs.mkdir(this.tempDir, { recursive: true });
      console.log('üìÅ AudioOptimizer inicializado');
      logger.info('AudioOptimizer inicializado', { tempDir: this.tempDir });
    } catch (error) {
      console.error('‚ùå Erro ao inicializar AudioOptimizer:', error);
      throw error;
    }
  }

  // Otimizar √°udio completo (velocidade + compress√£o)
  async optimizeAudio(inputBuffer, options = {}) {
    const config = { ...this.defaultConfig, ...options };
    const startTime = Date.now();
    
    try {
      console.log('üéµ Iniciando otimiza√ß√£o de √°udio...');
      
      // 1. Salvar buffer temporariamente
      const tempInputPath = await this.saveTemporaryFile(inputBuffer, 'input');
      
      // 2. Aplicar otimiza√ß√µes com FFmpeg
      const optimizedPath = await this.applyOptimizations(tempInputPath, config);
      
      // 3. Ler arquivo otimizado
      const optimizedBuffer = await fs.readFile(optimizedPath);
      
      // 4. Calcular m√©tricas
      const metrics = await this.calculateMetrics(inputBuffer, optimizedBuffer, config);
      
      // 5. Limpar arquivos tempor√°rios
      await this.cleanupTempFiles([tempInputPath, optimizedPath]);
      
      const processingTime = Date.now() - startTime;
      
      console.log('‚úÖ √Åudio otimizado com sucesso:', {
        originalSize: metrics.originalSize,
        optimizedSize: metrics.optimizedSize,
        compressionRatio: metrics.compressionRatio,
        tokenSavings: metrics.tokenSavings,
        processingTime: `${processingTime}ms`
      });
      
      logger.info('√Åudio otimizado', {
        metrics,
        processingTime,
        config
      });
      
      return {
        optimizedBuffer,
        metrics,
        config,
        processingTime
      };
      
    } catch (error) {
      console.error('‚ùå Erro na otimiza√ß√£o de √°udio:', error);
      logger.error('Erro na otimiza√ß√£o de √°udio', { error: error.message });
      throw error;
    }
  }

  // Salvar buffer como arquivo tempor√°rio
  async saveTemporaryFile(buffer, prefix = 'audio') {
    const timestamp = Date.now();
    const filename = `${prefix}_${timestamp}.mp3`;
    const filepath = path.join(this.tempDir, filename);
    
    await fs.writeFile(filepath, buffer);
    return filepath;
  }

  // Aplicar otimiza√ß√µes b√°sicas (sem FFmpeg)
  async applyOptimizations(inputPath, config) {
    try {
      console.log('‚ö†Ô∏è FFmpeg n√£o dispon√≠vel, usando otimiza√ß√£o b√°sica');
      
      // Para agora, apenas copiamos o arquivo sem modifica√ß√µes
      // Em produ√ß√£o, voc√™ pode usar bibliotecas JavaScript puras para processamento de √°udio
      const outputPath = inputPath.replace('input_', 'optimized_');
      
      // Simular processamento
      const fs = require('fs').promises;
      const inputBuffer = await fs.readFile(inputPath);
      await fs.writeFile(outputPath, inputBuffer);
      
      console.log('‚úÖ Otimiza√ß√£o b√°sica conclu√≠da (sem altera√ß√£o de velocidade)');
      return outputPath;
      
    } catch (error) {
      console.error('‚ùå Erro na otimiza√ß√£o b√°sica:', error);
      throw error;
    }
  }

  // Calcular m√©tricas de otimiza√ß√£o (modo b√°sico)
  async calculateMetrics(originalBuffer, optimizedBuffer, config) {
    const originalSize = originalBuffer.length;
    const optimizedSize = optimizedBuffer.length;
    const compressionRatio = ((originalSize - optimizedSize) / originalSize * 100).toFixed(2);
    
    // Estimar dura√ß√£o original (aproxima√ß√£o baseada no tamanho)
    // MP3 t√≠pico: ~1KB por segundo a 128kbps
    const estimatedOriginalDuration = Math.round(originalSize / 1024); // segundos
    
    // Sem FFmpeg, n√£o h√° altera√ß√£o de velocidade real, mas simulamos para compatibilidade
    const simulatedOptimizedDuration = Math.round(estimatedOriginalDuration / config.speed);
    
    // Calcular economia de tokens simulada (32 tokens por segundo)
    const originalTokens = estimatedOriginalDuration * 32;
    const simulatedOptimizedTokens = simulatedOptimizedDuration * 32;
    const simulatedTokenSavings = originalTokens - simulatedOptimizedTokens;
    const simulatedTokenSavingsPercent = ((simulatedTokenSavings / originalTokens) * 100).toFixed(2);
    
    return {
      originalSize,
      optimizedSize,
      compressionRatio: `${compressionRatio}%`,
      estimatedOriginalDuration,
      optimizedDuration: simulatedOptimizedDuration,
      originalTokens,
      optimizedTokens: simulatedOptimizedTokens,
      tokenSavings: simulatedTokenSavings,
      tokenSavingsPercent: `${simulatedTokenSavingsPercent}%`,
      note: 'M√©tricas simuladas - FFmpeg n√£o dispon√≠vel'
    };
  }

  // Limpar arquivos tempor√°rios
  async cleanupTempFiles(filePaths) {
    try {
      await Promise.all(
        filePaths.map(async (filepath) => {
          try {
            await fs.unlink(filepath);
            console.log(`üóëÔ∏è Arquivo tempor√°rio removido: ${path.basename(filepath)}`);
          } catch (error) {
            // Ignorar erros de arquivo n√£o encontrado
            if (error.code !== 'ENOENT') {
              console.warn(`‚ö†Ô∏è Erro ao remover arquivo tempor√°rio: ${error.message}`);
            }
          }
        })
      );
    } catch (error) {
      console.warn('‚ö†Ô∏è Erro na limpeza de arquivos tempor√°rios:', error.message);
    }
  }

  // Validar se √°udio pode ser otimizado
  validateAudioBuffer(buffer) {
    if (!buffer || buffer.length === 0) {
      throw new Error('Buffer de √°udio vazio ou inv√°lido');
    }
    
    // Verificar tamanho m√°ximo (40MB)
    const maxSize = 40 * 1024 * 1024; // 40MB
    if (buffer.length > maxSize) {
      throw new Error(`Arquivo muito grande: ${(buffer.length / 1024 / 1024).toFixed(2)}MB. M√°ximo: 40MB`);
    }
    
    return true;
  }

  // Configura√ß√µes predefinidas
  getPresetConfigs() {
    return {
      // M√°xima economia (pode afetar qualidade)
      aggressive: {
        speed: 1.8,
        bitrate: '96k',
        sampleRate: 16000,
        format: 'mp3'
      },
      
      // Balanceado (recomendado)
      balanced: {
        speed: 1.5,
        bitrate: '128k',
        sampleRate: 16000,
        format: 'mp3'
      },
      
      // Conservador (melhor qualidade)
      conservative: {
        speed: 1.2,
        bitrate: '192k',
        sampleRate: 22050,
        format: 'mp3'
      },
      
      // Apenas compress√£o (sem altera√ß√£o de velocidade)
      compressionOnly: {
        speed: 1.0,
        bitrate: '128k',
        sampleRate: 16000,
        format: 'mp3'
      }
    };
  }

  // Obter configura√ß√£o por nome
  getPresetConfig(presetName) {
    const presets = this.getPresetConfigs();
    return presets[presetName] || presets.balanced;
  }

  // Estimar economia antes da otimiza√ß√£o
  estimateOptimization(bufferSize, config = this.defaultConfig) {
    const estimatedDuration = Math.round(bufferSize / 1024); // segundos
    const optimizedDuration = Math.round(estimatedDuration / config.speed);
    
    const originalTokens = estimatedDuration * 32;
    const optimizedTokens = optimizedDuration * 32;
    const tokenSavings = originalTokens - optimizedTokens;
    
    return {
      estimatedDuration,
      optimizedDuration,
      originalTokens,
      optimizedTokens,
      tokenSavings,
      tokenSavingsPercent: ((tokenSavings / originalTokens) * 100).toFixed(2) + '%'
    };
  }
}

module.exports = AudioOptimizer;