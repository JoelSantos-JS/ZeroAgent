const whatsappService = require('./whatsapp-service');
const databaseService = require('../config/database');
const userService = require('./user-service');
const geminiService = require('./gemini-service');
const logger = require('../utils/logger');
const moment = require('moment');

class FinancialAgent {
  constructor() {
    this.isInitialized = false;
    this.processingQueue = new Map(); // Para evitar processamento duplicado
    this.conversationHistory = new Map(); // phoneNumber -> array of last messages
    this.maxHistorySize = 5; // Manter √∫ltimas 5 mensagens por usu√°rio
  }

  // Inicializar o agente financeiro
  async initialize() {
    try {
      console.log('ü§ñ Inicializando Agente Financeiro...');
      
      // Inicializar servi√ßos
      await databaseService.initialize();
      await geminiService.initialize();
      
      // Configurar processador de mensagens no WhatsApp Service
      whatsappService.setMessageProcessor(this);
      
      this.isInitialized = true;
      console.log('‚úÖ Agente Financeiro inicializado com sucesso!');
      logger.info('Agente Financeiro inicializado');
      
    } catch (error) {
      console.error('‚ùå Erro ao inicializar Agente Financeiro:', error);
      logger.error('Erro na inicializa√ß√£o do Agente Financeiro', { error: error.message });
      throw error;
    }
  }

  // Processar mensagem recebida do WhatsApp
  async processMessage(message) {
    const messageId = message.id._serialized;
    
    // Evitar processamento duplicado
    if (this.processingQueue.has(messageId)) {
      console.log('‚ö†Ô∏è Mensagem j√° est√° sendo processada:', messageId);
      return null;
    }
    
    this.processingQueue.set(messageId, true);
    
    try {
      console.log(`üîÑ Processando mensagem: ${message.body}`);
      
      // Adicionar mensagem do usu√°rio ao hist√≥rico
      this.addToConversationHistory(message.from, message.body, 'user');
      
      // Verificar se usu√°rio est√° autenticado
      const authStatus = await this.checkUserAuthentication(message.from);
      
      if (!authStatus.isAuthenticated) {
        // Processar fluxo de autentica√ß√£o
        const authResponse = await this.handleAuthenticationFlow(message.from, message.body, authStatus.step);
        return authResponse;
      }
      
      // Usu√°rio autenticado - processar mensagem normalmente
      const user = authStatus.user;
      
      // Obter contexto da conversa
      const conversationContext = this.getConversationContext(message.from);
      
      // Analisar se √© uma mensagem contextual
      const contextAnalysis = this.analyzeContextualMessage(message.body, conversationContext);
      
      // Processar mensagem com contexto
      let analysisResult;
      if (contextAnalysis.isContextual) {
        console.log('üîó Mensagem contextual detectada:', contextAnalysis);
        analysisResult = {
          tipo: 'consulta',
          intencao: contextAnalysis.originalIntent || 'consultar_gastos',
          categoria: 'consulta',
          valor: 0,
          descricao: message.body,
          confianca: 0.9,
          analise: 'An√°lise contextual baseada no hist√≥rico',
          dica: 'Vou buscar os detalhes solicitados!'
        };
      } else {
        // Processar mensagem com Gemini
        const userContext = await this.getUserContext(user.id);
        analysisResult = await geminiService.processFinancialMessage(message.body, userContext);
      }
      
      console.log('üß† An√°lise do Gemini:', analysisResult);
      
      // Salvar an√°lise no hist√≥rico
      const history = this.conversationHistory.get(message.from);
      if (history && history.length > 0) {
        history[history.length - 1].analysis = analysisResult;
      }
      
      // Processar baseado no tipo identificado
      let response;
      switch (analysisResult.tipo) {
        case 'receita':
          response = await this.processIncomeTransaction(user.id, analysisResult);
          break;
        case 'despesa_fixa':
        case 'despesa_variavel':
          response = await this.processExpenseTransaction(user.id, analysisResult);
          break;
        case 'investimento':
          response = await this.processInvestmentTransaction(user.id, analysisResult);
          break;
        case 'consulta':
          // Verificar se √© consulta detalhada
          if (analysisResult.intencao === 'consultar_gastos_detalhado' || 
              (contextAnalysis.isContextual && contextAnalysis.referenceType.includes('consulta'))) {
            response = await this.processDetailedQuery(user.id, analysisResult);
          } else {
            response = await this.processQuery(user.id, analysisResult);
          }
          break;
        default:
          response = await this.processOtherMessage(user.id, analysisResult);
      }
      
      logger.info('Mensagem processada com sucesso', {
        userId: user.id,
        messageType: analysisResult.tipo,
        confidence: analysisResult.confianca
      });
      
      return response;
      
    } catch (error) {
      console.error('‚ùå Erro ao processar mensagem:', error);
      logger.error('Erro no processamento de mensagem', {
        messageId,
        error: error.message
      });
      
      return '‚ùå Desculpe, ocorreu um erro ao processar sua mensagem. Tente novamente em alguns instantes.';
      
    } finally {
      // Remover da fila de processamento
      setTimeout(() => {
        this.processingQueue.delete(messageId);
      }, 5000); // Manter por 5 segundos para evitar duplicatas
    }
  }

  // Adicionar mensagem ao hist√≥rico de conversa
   addToConversationHistory(phoneNumber, message, type = 'user') {
     if (!this.conversationHistory.has(phoneNumber)) {
       this.conversationHistory.set(phoneNumber, []);
     }
     
     const history = this.conversationHistory.get(phoneNumber);
     history.push({
       message: message,
       type: type, // 'user' ou 'bot'
       timestamp: new Date(),
       analysis: null
     });
     
     // Manter apenas as √∫ltimas mensagens
     if (history.length > this.maxHistorySize) {
       history.shift();
     }
   }
   
   // Obter contexto da conversa
   getConversationContext(phoneNumber) {
     const history = this.conversationHistory.get(phoneNumber) || [];
     return history.slice(-3); // √öltimas 3 mensagens para contexto
   }
   
   // Analisar se mensagem atual √© contextual baseada no hist√≥rico
    analyzeContextualMessage(message, history) {
      const messageLower = message.toLowerCase();
      
      // Palavras que indicam refer√™ncia a mensagem anterior
      const contextualWords = {
        consulta: ['mostre', 'detalhe', 'cada', 'lista', 'veja', 'exiba', 'me fale', 'conte', 
                  'explique', 'isso', 'elas', 'eles', 'me diga', 'mostra', 'apresente',
                  'discrimine', 'especifique', 'detalha', 'uma por uma', 'separadamente'],
        confirmacao: ['sim', 'ok', 'certo', 'confirmo', 'pode', 'vai', 'continua', 'prossiga'],
        negacao: ['n√£o', 'nao', 'cancel', 'para', 'stop', 'volta', 'sair']
      };
      
      // Verificar diferentes tipos de contexto
      if (history.length > 0) {
        const lastMessage = history[history.length - 1];
        const lastBotMessage = history.slice().reverse().find(h => h.type === 'bot');
        
        // 1. Refer√™ncia direta a consulta anterior
        const hasConsultaWord = contextualWords.consulta.some(word => messageLower.includes(word));
        if (hasConsultaWord && lastMessage.analysis && lastMessage.analysis.tipo === 'consulta') {
          return {
            isContextual: true,
            referenceType: 'consulta_detalhada',
            originalIntent: 'consultar_gastos_detalhado',
            confidence: 0.95
          };
        }
        
        // 2. Mensagens muito curtas ap√≥s consulta (prov√°vel continua√ß√£o)
        if (message.length <= 20 && lastMessage.analysis && lastMessage.analysis.tipo === 'consulta') {
          const hasConfirmacao = contextualWords.confirmacao.some(word => messageLower.includes(word));
          if (hasConfirmacao) {
            return {
              isContextual: true,
              referenceType: 'confirmacao_consulta',
              originalIntent: 'consultar_gastos_detalhado',
              confidence: 0.9
            };
          }
        }
        
        // 3. Pronomes e refer√™ncias impl√≠citas
        const pronouns = ['isso', 'elas', 'eles', 'essa', 'essas', 'este', 'esta'];
        const hasPronoun = pronouns.some(word => messageLower.includes(word));
        if (hasPronoun && history.length >= 2) {
          const recentConsulta = history.slice(-3).find(h => h.analysis && h.analysis.tipo === 'consulta');
          if (recentConsulta) {
            return {
              isContextual: true,
              referenceType: 'pronome_referencia',
              originalIntent: 'consultar_gastos_detalhado',
              confidence: 0.85
            };
          }
        }
        
        // 4. Padr√£o de pergunta seguida de especifica√ß√£o
        if (history.length >= 2) {
          const penultimate = history[history.length - 2];
          if (penultimate.analysis && penultimate.analysis.tipo === 'consulta' && 
              messageLower.length < 30 && hasConsultaWord) {
            return {
              isContextual: true,
              referenceType: 'especificacao_consulta',
              originalIntent: 'consultar_gastos_detalhado',
              confidence: 0.9
            };
          }
        }
      }
      
      return { isContextual: false };
    }

   // Verificar autentica√ß√£o do usu√°rio
    async checkUserAuthentication(phoneNumber) {
      try {
        console.log(`üîç Verificando autentica√ß√£o para: ${phoneNumber}`);
        
        // Verificar se existe sess√£o ativa
        const session = await databaseService.getUserSession(phoneNumber);
        console.log(`üìã Sess√£o encontrada:`, session);
        
        if (session && session.is_active) {
          const user = await userService.getUserById(session.user_id);
          console.log(`üë§ Usu√°rio encontrado:`, user?.name);
          
          return {
            isAuthenticated: true,
            user: user,
            step: null
          };
        }
      
      // Verificar se est√° no processo de autentica√ß√£o
      const authProcess = await databaseService.getAuthProcess(phoneNumber);
      
      if (authProcess) {
        return {
          isAuthenticated: false,
          user: null,
          step: authProcess.step
        };
      }
      
      // Novo usu√°rio - iniciar processo de autentica√ß√£o
      return {
        isAuthenticated: false,
        user: null,
        step: 'welcome'
      };
      
    } catch (error) {
      console.error('‚ùå Erro ao verificar autentica√ß√£o:', error);
      return {
        isAuthenticated: false,
        user: null,
        step: 'welcome'
      };
    }
  }

  // Gerenciar fluxo de autentica√ß√£o
  async handleAuthenticationFlow(phoneNumber, message, step) {
    try {
      switch (step) {
        case 'welcome':
          // Iniciar processo de autentica√ß√£o
          await databaseService.createAuthProcess(phoneNumber, 'email');
          return 'üëã Ol√°! Bem-vindo ao **Financial Agent**! ü§ñüí∞\n\n' +
                 'Sou seu assistente financeiro pessoal e vou te ajudar a:\n' +
                 'üí∞ Registrar gastos e receitas\n' +
                 'üìä Acompanhar seu or√ßamento\n' +
                 'üìà Analisar seus h√°bitos financeiros\n' +
                 'üõí Gerenciar produtos e compras\n\n' +
                 'üîê **Para sua seguran√ßa**, preciso que voc√™ se identifique primeiro.\n\n' +
                 'üìß **Digite seu email:**';
        
        case 'email':
          // Validar email e solicitar senha
          const email = message.trim().toLowerCase();
          
          if (!this.isValidEmail(email)) {
            return '‚ùå Email inv√°lido. Por favor, digite um email v√°lido:';
          }
          
          await databaseService.updateAuthProcess(phoneNumber, 'password', { email });
          return '‚úÖ **Email registrado com sucesso!**\n\nüîë **Agora digite sua senha:**\n\nüí° *Sua senha deve ter pelo menos 6 caracteres*';
        
        case 'password':
          // Validar credenciais
          const authProcess = await databaseService.getAuthProcess(phoneNumber);
          const userEmail = authProcess.data.email;
          const password = message.trim();
          
          // Autenticar com Firebase
          const authResult = await userService.authenticateUser(userEmail, password);
          
          if (authResult.success) {
            // Criar sess√£o
            await databaseService.createUserSession(phoneNumber, authResult.user.id);
            await databaseService.deleteAuthProcess(phoneNumber);
            
            return `üéâ **Autentica√ß√£o realizada com sucesso!**\n\n` +
                   `üëã Ol√°, **${authResult.user.name}**! Seja bem-vindo(a)!\n\n` +
                   `ü§ñ **Agora estou pronto para te ajudar!** Voc√™ pode:\n\n` +
                   `üí∞ *"Gastei 50 reais no supermercado"*\n` +
                   `üíµ *"Recebi 1000 reais de sal√°rio"*\n` +
                   `üìä *"Quanto gastei este m√™s?"*\n` +
                   `üõí *"Comprei um notebook por 2000 reais"*\n` +
                   `üìà *"Investi 500 reais na poupan√ßa"*\n\n` +
                   `‚ú® **Como posso te ajudar hoje?**`;
          } else {
             // Falha na autentica√ß√£o
             await databaseService.updateAuthProcess(phoneNumber, 'email');
             return '‚ùå **Email ou senha incorretos.**\n\nüîÑ Vamos tentar novamente!\n\nüìß **Digite seu email:**';
          }
        
        default:
           await databaseService.deleteAuthProcess(phoneNumber);
           return this.handleAuthenticationFlow(phoneNumber, message, 'welcome');
      }
      
    } catch (error) {
       console.error('‚ùå Erro no fluxo de autentica√ß√£o:', error);
       await databaseService.deleteAuthProcess(phoneNumber);
       return '‚ö†Ô∏è **Ops! Algo deu errado.**\n\nüîÑ Vamos recome√ßar!\n\nüëã Ol√°! Bem-vindo ao **Financial Agent**! ü§ñüí∞\n\nüìß **Digite seu email para come√ßar:**';
    }
  }

  // Validar formato de email
  isValidEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  // Obter contexto do usu√°rio
  async getUserContext(userId) {
    try {
      const stats = await userService.getUserStats(userId);
      const recentTransactions = await databaseService.getUserTransactions(userId, 5);
      
      return {
        totalSpent: stats.totalSpent,
        monthlySpent: stats.monthlySpent,
        recentTransactions: recentTransactions.map(t => ({
          value: t.amount,
          category: t.category,
          description: t.description,
          date: t.date
        })),
        topCategories: stats.topCategories
      };
    } catch (error) {
      console.error('‚ùå Erro ao obter contexto do usu√°rio:', error);
      return {};
    }
  }

  // Processar transa√ß√£o de despesa (fixa ou vari√°vel)
  async processExpenseTransaction(userId, analysisResult) {
    try {
      const { valor, categoria, descricao, data, tipo, analise, dica } = analysisResult;
      
      // Processar data
      const transactionDate = this.parseDate(data);
      
      // Registrar transa√ß√£o no banco
      const transaction = await databaseService.createTransaction(
        userId,
        valor,
        categoria,
        descricao,
        transactionDate,
        'other'  // Tipo da transa√ß√£o (enum expense_type)
      );
      
      console.log(`üí∏ ${tipo.toUpperCase()} registrada:`, transaction);
      
      // Obter contexto atualizado para resposta personalizada
      const userContext = await this.getUserContext(userId);
      
      // Gerar resposta mais humana e natural
       const tipoFormatado = tipo === 'despesa_fixa' ? 'despesa fixa' : 'despesa vari√°vel';
       const categoriaFormatada = categoria ? categoria.charAt(0).toUpperCase() + categoria.slice(1) : 'Outros';
      
      // Mensagens mais naturais baseadas na categoria
      const mensagensCategoria = {
        'alimentacao': 'Anotei seu gasto com alimenta√ß√£o! üçΩÔ∏è',
        'transporte': 'Registrei sua despesa de transporte! üöó',
        'supermercado': 'Compra do supermercado anotada! üõí',
        'lazer': 'Divers√£o tamb√©m √© importante! üéâ',
        'saude': 'Cuidar da sa√∫de √© investimento! üíä',
        'casa': 'Despesa dom√©stica registrada! üè†',
        'roupas': 'Nova pe√ßa no guarda-roupa! üëï',
        'outros': 'Despesa registrada com sucesso! ‚úÖ'
      };
      
      const mensagemInicial = mensagensCategoria[categoria] || mensagensCategoria['outros'];
      
      let response = `${mensagemInicial}\n\n`;
      response += `üí∞ **R$ ${valor.toFixed(2)}** em ${categoriaFormatada}\n`;
      
      // Adicionar contexto do or√ßamento se dispon√≠vel
       if (userContext.monthlySpent !== undefined && userContext.monthlySpent !== null) {
         const monthlySpent = parseFloat(userContext.monthlySpent) || 0;
         const novoTotal = monthlySpent + valor;
         response += `üìä Total do m√™s: R$ ${novoTotal.toFixed(2)}\n\n`;
       }
      
      // Dica personalizada e mais humana
      const dicasPersonalizadas = {
        'alimentacao': 'Que tal planejar as refei√ß√µes da semana? Ajuda a economizar! ü•ó',
        'transporte': 'Considere alternativas como transporte p√∫blico ou carona! üöå',
        'supermercado': 'Fazer lista de compras evita gastos desnecess√°rios! üìù',
        'lazer': 'Divers√£o √© importante, mas sempre dentro do or√ßamento! üéØ',
        'saude': 'Investir em preven√ß√£o pode economizar muito no futuro! üí™',
        'casa': 'Manter a casa organizada ajuda a controlar os gastos! üßπ',
        'roupas': 'Antes de comprar, veja se realmente precisa! üëÄ'
      };
      
      const dicaFinal = dica || dicasPersonalizadas[categoria] || 'Continue registrando seus gastos para ter controle total das finan√ßas! üìà';
      response += `üí° ${dicaFinal}`;
      
      logger.info(`${tipo} registrada`, {
        userId,
        transactionId: transaction.id,
        value: valor,
        category: categoria
      });
      
      return response;
      
    } catch (error) {
      console.error('‚ùå Erro ao processar despesa:', error);
      logger.error('Erro ao processar despesa', {
        userId,
        analysisResult,
        error: error.message
      });
      
      return `‚ùå Erro ao registrar despesa de R$ ${analysisResult.valor}. Tente novamente.`;
    }
  }

  // Processar transa√ß√£o de receita
  async processIncomeTransaction(userId, analysisResult) {
    try {
      const { valor, categoria, descricao, data, analise, dica } = analysisResult;
      
      // Processar data
      const transactionDate = this.parseDate(data);
      
      // Registrar receita no banco usando tabela revenues
      const transaction = await databaseService.createRevenue(
        userId,
        valor,
        categoria,
        descricao,
        transactionDate,
        'other'  // Source da receita
      );
      
      console.log('üí∞ Receita registrada:', transaction);
      
      // Obter contexto atualizado para resposta personalizada
      const userContext = await this.getUserContext(userId);
      
      // Gerar resposta mais humana e natural
      const categoriaFormatada = categoria ? categoria.charAt(0).toUpperCase() + categoria.slice(1) : 'Outros';
      
      // Mensagens mais naturais baseadas na categoria
      const mensagensCategoria = {
        'salario': 'Sal√°rio recebido! üíº',
        'freelance': 'Trabalho freelance registrado! üíª',
        'vendas': 'Venda realizada com sucesso! üí∞',
        'bonus': 'B√¥nus recebido! üéâ',
        'investimento': 'Retorno de investimento! üìà',
        'outros': 'Receita registrada com sucesso! ‚úÖ'
      };
      
      const mensagemInicial = mensagensCategoria[categoria] || mensagensCategoria['outros'];
      
      let response = `${mensagemInicial}\n\n`;
      response += `üí∞ **R$ ${valor.toFixed(2)}** em ${categoriaFormatada}\n`;
      
      // Dicas personalizadas para receitas
      const dicasPersonalizadas = {
        'salario': 'Que tal separar uma parte para investimentos? üí°',
        'freelance': 'Considere guardar 20% para impostos! üìä',
        'vendas': '√ìtimo! Continue focando nas vendas! üöÄ',
        'bonus': 'Uma boa oportunidade para investir ou quitar d√≠vidas! üí™',
        'investimento': 'Seus investimentos est√£o dando retorno! Continue assim! üìà'
      };
      
      const dicaFinal = dica || dicasPersonalizadas[categoria] || 'Continue registrando suas receitas para ter controle total das finan√ßas! üìà';
      response += `üí° ${dicaFinal}`;
      
      logger.info('Receita registrada', {
        userId,
        transactionId: transaction.id,
        value: valor,
        category: categoria
      });
      
      return response;
      
    } catch (error) {
      console.error('‚ùå Erro ao processar receita:', error);
      logger.error('Erro ao processar receita', {
        userId,
        analysisResult,
        error: error.message
      });
      
      return `‚ùå Erro ao registrar receita de R$ ${analysisResult.valor}. Tente novamente.`;
    }
  }

  // Processar transa√ß√£o de investimento
  async processInvestmentTransaction(userId, analysisResult) {
    try {
      const { valor, categoria, descricao, data, analise, dica } = analysisResult;
      
      // Processar data
      const transactionDate = this.parseDate(data);
      
      // Registrar investimento no banco
      const transaction = await databaseService.createTransaction(
        userId,
        valor,
        categoria,
        descricao,
        transactionDate,
        'expense'  // Investimentos como despesa no sistema
      );
      
      console.log('üìà Investimento registrado:', transaction);
      
      // Tamb√©m registrar como produto se houver nome espec√≠fico
      if (analysisResult.produto_nome) {
        await databaseService.createProduct(
          userId,
          analysisResult.produto_nome,
          categoria,
          valor,
          transactionDate
        );
      }
      
      // Obter contexto atualizado
      const userContext = await this.getUserContext(userId);
      
      // Gerar resposta no formato do analista financeiro
      const currentDateTime = new Date().toLocaleString('pt-BR');
      const response = `‚úÖ INVESTIMENTO registrado: R$ ${valor.toFixed(2)} em ${categoria.toUpperCase()} em ${currentDateTime}\nüìä Impacto: ${analise || 'Investimento adicionado ao seu portf√≥lio'}\nüí° Dica: ${dica || 'Parab√©ns por investir! Continue diversificando seus investimentos.'}`;
      
      logger.info('Investimento registrado', {
        userId,
        transactionId: transaction.id,
        value: valor,
        category: categoria
      });
      
      return response;
      
    } catch (error) {
      console.error('‚ùå Erro ao processar investimento:', error);
      logger.error('Erro ao processar investimento', {
        userId,
        analysisResult,
        error: error.message
      });
      
      return `‚ùå Erro ao registrar investimento de R$ ${analysisResult.valor}. Tente novamente.`;
    }
  }

  // Processar consulta
  async processQuery(userId, analysisResult) {
    try {
      const { intencao } = analysisResult;
      
      console.log('üìä Processando consulta:', intencao);
      
      let response;
      
      switch (intencao) {
        case 'consultar_gastos_mes':
        case 'gastos_mes':
          response = await this.getMonthlyExpenses(userId);
          break;
        case 'consultar_gastos_categoria':
          response = await this.getCategoryExpenses(userId, analysisResult.categoria);
          break;
        case 'consultar_produtos':
        case 'listar_produtos':
          response = await this.getUserProducts(userId);
          break;
        case 'consultar_saldo':
        case 'saldo':
          response = await this.getUserBalance(userId);
          break;
        case 'relatorio':
        case 'resumo':
          response = await this.getUserSummary(userId);
          break;
        default:
          response = await this.getGeneralStats(userId);
      }
      
      logger.info('Consulta processada', {
        userId,
        queryType: intencao
      });
      
      return response;
      
    } catch (error) {
      console.error('‚ùå Erro ao processar consulta:', error);
      logger.error('Erro ao processar consulta', {
        userId,
        analysisResult,
        error: error.message
      });
      
      return '‚ùå Erro ao processar sua consulta. Tente novamente.';
    }
  }

  // Processar consulta detalhada
  async processDetailedQuery(userId, analysisResult) {
    try {
      console.log('üîç Processando consulta detalhada');
      
      // Obter transa√ß√µes recentes do usu√°rio
      const transactions = await databaseService.getUserTransactions(userId, 10);
      
      if (transactions.length === 0) {
        return 'üìä Voc√™ ainda n√£o possui transa√ß√µes registradas.';
      }
      
      let response = `üìä **Suas √∫ltimas transa√ß√µes:**\n\n`;
      
      transactions.forEach((transaction, index) => {
         const date = moment(transaction.transaction_date).format('DD/MM/YYYY HH:mm');
         const value = parseFloat(transaction.value);
         const isRevenue = transaction.transaction_type === 'revenue';
         
         // Emojis por categoria
         const categoryEmojis = {
           'alimentacao': 'üçΩÔ∏è',
           'transporte': 'üöó',
           'lazer': 'üéâ',
           'saude': 'üè•',
           'educacao': 'üìö',
           'casa': 'üè†',
           'roupas': 'üëï',
           'salario': 'üíº',
           'freelance': 'üíª',
           'vendas': 'üõí',
           'aplicacao': 'üìà',
           'outros': 'üìã'
         };
         
         const categoryEmoji = categoryEmojis[transaction.category] || 'üìã';
         const typeEmoji = isRevenue ? 'üí∞' : 'üí∏';
         const valueColor = isRevenue ? '+' : '-';
         
         response += `${typeEmoji} ${categoryEmoji} **${transaction.category.toUpperCase()}**\n`;
         response += `   üíµ ${valueColor}R$ ${value.toFixed(2)}`;
         response += ` | üìÖ ${date}\n`;
         
         if (transaction.description && transaction.description.trim()) {
           response += `   üìù ${transaction.description}\n`;
         }
         
         response += '\n';
       });
      
      // Adicionar resumo
      const totalExpenses = transactions
        .filter(t => t.transaction_type === 'expense')
        .reduce((sum, t) => sum + parseFloat(t.value), 0);
      
      const totalRevenues = transactions
        .filter(t => t.transaction_type === 'revenue')
        .reduce((sum, t) => sum + parseFloat(t.value), 0);
      
      response += `üìà **Resumo das √∫ltimas ${transactions.length} transa√ß√µes:**\n`;
      response += `üí∏ Gastos: R$ ${totalExpenses.toFixed(2)}\n`;
      response += `üí∞ Receitas: R$ ${totalRevenues.toFixed(2)}\n`;
      response += `üìä Saldo: R$ ${(totalRevenues - totalExpenses).toFixed(2)}`;
      
      logger.info('Consulta detalhada processada', {
        userId,
        transactionCount: transactions.length
      });
      
      return response;
      
    } catch (error) {
      console.error('‚ùå Erro ao processar consulta detalhada:', error);
      logger.error('Erro ao processar consulta detalhada', {
        userId,
        error: error.message
      });
      
      return '‚ùå Erro ao processar consulta detalhada. Tente novamente.';
    }
  }

  // Processar outras mensagens
  async processOtherMessage(userId, analysisResult) {
    try {
      // Se a confian√ßa for muito baixa, pedir esclarecimento
      if (analysisResult.confianca < 0.5) {
        return 'ü§î N√£o consegui entender sua mensagem. Voc√™ pode tentar algo como:\n\n' +
               '‚Ä¢ "Gastei 50 reais no supermercado"\n' +
               '‚Ä¢ "Comprei um celular por 800 reais"\n' +
               '‚Ä¢ "Quanto gastei este m√™s?"\n' +
               '‚Ä¢ "Mostre meus produtos"';
      }
      
      // Tentar processar como gasto gen√©rico se houver valor
      if (analysisResult.valor > 0) {
        return await this.processExpenseTransaction(userId, {
          ...analysisResult,
          tipo: 'gasto',
          categoria: 'outros'
        });
      }
      
      // Resposta padr√£o
      return 'üëã Ol√°! Sou seu assistente financeiro. Posso ajudar voc√™ a:\n\n' +
             'üí∞ Registrar gastos\n' +
             'üõí Registrar produtos\n' +
             'üìä Consultar relat√≥rios\n' +
             'üí≥ Ver resumos financeiros\n\n' +
             'Como posso ajudar voc√™ hoje?';
      
    } catch (error) {
      console.error('‚ùå Erro ao processar mensagem gen√©rica:', error);
      return '‚ùå Erro ao processar mensagem. Tente novamente.';
    }
  }

  // Obter gastos mensais
  async getMonthlyExpenses(userId) {
    try {
      const currentDate = new Date();
      const expenses = await databaseService.getUserMonthlyExpenses(
        userId,
        currentDate.getFullYear(),
        currentDate.getMonth() + 1
      );
      
      const total = Object.values(expenses).reduce((sum, value) => sum + value, 0);
      
      if (total === 0) {
        return 'üìä Voc√™ ainda n√£o registrou gastos este m√™s.';
      }
      
      let response = `üìä **Gastos de ${moment().format('MMMM/YYYY')}**\n\n`;
      response += `üí∞ **Total: R$ ${total.toFixed(2)}**\n\n`;
      
      const sortedExpenses = Object.entries(expenses)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 5);
      
      response += '**Por categoria:**\n';
      for (const [category, amount] of sortedExpenses) {
        const percentage = ((amount / total) * 100).toFixed(1);
        response += `‚Ä¢ ${category}: R$ ${amount.toFixed(2)} (${percentage}%)\n`;
      }
      
      return response;
      
    } catch (error) {
      console.error('‚ùå Erro ao obter gastos mensais:', error);
      return '‚ùå Erro ao consultar gastos mensais.';
    }
  }

  // Obter gastos por categoria
  async getCategoryExpenses(userId, category) {
    try {
      const currentDate = new Date();
      const startOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
      const endOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
      
      const transactions = await databaseService.getUserTransactionsByCategory(
        userId,
        category,
        startOfMonth,
        endOfMonth
      );
      
      if (transactions.length === 0) {
        return `üìä Voc√™ n√£o tem gastos em ${category} este m√™s.`;
      }
      
      const total = transactions.reduce((sum, t) => sum + parseFloat(t.amount), 0);
      
      let response = `üìä **Gastos em ${category} - ${moment().format('MMMM/YYYY')}**\n\n`;
      response += `üí∞ **Total: R$ ${total.toFixed(2)}**\n`;
      response += `üìà **Transa√ß√µes: ${transactions.length}**\n\n`;
      
      response += '**√öltimas transa√ß√µes:**\n';
      transactions.slice(0, 5).forEach(t => {
        const date = moment(t.date).format('DD/MM');
        response += `‚Ä¢ ${date}: R$ ${parseFloat(t.amount).toFixed(2)} - ${t.description || 'Sem descri√ß√£o'}\n`;
      });
      
      return response;
      
    } catch (error) {
      console.error('‚ùå Erro ao obter gastos por categoria:', error);
      return '‚ùå Erro ao consultar gastos por categoria.';
    }
  }

  // Obter produtos do usu√°rio
  async getUserProducts(userId) {
    try {
      const products = await databaseService.getUserProducts(userId, 10);
      
      if (products.length === 0) {
        return 'üõí Voc√™ ainda n√£o registrou nenhum produto.';
      }
      
      let response = `üõí **Seus produtos (${products.length} registrados)**\n\n`;
      
      products.forEach(product => {
        const date = moment(product.purchase_date).format('DD/MM/YYYY');
        response += `‚Ä¢ **${product.product_name}**\n`;
        response += `  üí∞ R$ ${parseFloat(product.price).toFixed(2)}\n`;
        response += `  üìÖ ${date}\n`;
        if (product.product_category) {
          response += `  üè∑Ô∏è ${product.product_category}\n`;
        }
        response += '\n';
      });
      
      return response;
      
    } catch (error) {
      console.error('‚ùå Erro ao obter produtos:', error);
      return '‚ùå Erro ao consultar produtos.';
    }
  }

  // Obter resumo do usu√°rio
  async getUserSummary(userId) {
    try {
      const stats = await userService.getUserStats(userId);
      
      let response = `üìä **Resumo Financeiro**\n\n`;
      response += `üí∞ **Total gasto:** R$ ${stats.totalSpent.toFixed(2)}\n`;
      response += `üìÖ **Este m√™s:** R$ ${stats.monthlySpent.toFixed(2)}\n`;
      response += `üìà **Transa√ß√µes:** ${stats.totalTransactions}\n`;
      response += `üõí **Produtos:** ${stats.totalProducts}\n\n`;
      
      if (stats.topCategories.length > 0) {
        response += '**Top categorias este m√™s:**\n';
        stats.topCategories.forEach(cat => {
          response += `‚Ä¢ ${cat.category}: R$ ${cat.amount.toFixed(2)}\n`;
        });
      }
      
      return response;
      
    } catch (error) {
      console.error('‚ùå Erro ao obter resumo:', error);
      return '‚ùå Erro ao gerar resumo.';
    }
  }

  // Obter estat√≠sticas gerais
  async getGeneralStats(userId) {
    try {
      const stats = await userService.getUserStats(userId);
      
      return `üìä Voc√™ tem ${stats.totalTransactions} transa√ß√µes registradas, ` +
             `totalizando R$ ${stats.totalSpent.toFixed(2)}. ` +
             `Este m√™s voc√™ gastou R$ ${stats.monthlySpent.toFixed(2)}.`;
      
    } catch (error) {
      console.error('‚ùå Erro ao obter estat√≠sticas:', error);
      return '‚ùå Erro ao consultar estat√≠sticas.';
    }
  }

  // Parsear data
  parseDate(dateString) {
    const today = new Date();
    
    switch (dateString.toLowerCase()) {
      case 'hoje':
        return today;
      case 'ontem':
        return new Date(today.getTime() - 24 * 60 * 60 * 1000);
      case 'anteontem':
        return new Date(today.getTime() - 2 * 24 * 60 * 60 * 1000);
      default:
        // Tentar parsear data espec√≠fica
        const parsed = moment(dateString, ['DD/MM/YYYY', 'DD/MM', 'YYYY-MM-DD'], true);
        return parsed.isValid() ? parsed.toDate() : today;
    }
  }

  // Verificar se est√° pronto
  isReady() {
    return this.isInitialized && 
           databaseService.isConnected && 
           geminiService.isReady();
  }

  // Obter status
  getStatus() {
    return {
      isInitialized: this.isInitialized,
      database: databaseService.isConnected,
      gemini: geminiService.isReady(),
      whatsapp: whatsappService.getStatus(),
      processingQueue: this.processingQueue.size
    };
  }
}

// Inst√¢ncia singleton
const financialAgent = new FinancialAgent();

module.exports = financialAgent;
module.exports.FinancialAgent = FinancialAgent;