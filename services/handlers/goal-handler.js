const BaseHandler = require('./base-handler');
const DataParser = require('../parsers/data-parser');
const ResponseFormatter = require('../formatters/response-formatter');
const moment = require('moment');

/**
 * Handler espec√≠fico para processamento de metas financeiras
 * Processa comandos relacionados a cria√ß√£o, consulta e gerenciamento de metas
 */
class GoalHandler extends BaseHandler {
  constructor(databaseService, userService, goalModel) {
    super(databaseService, userService);
    this.goalModel = goalModel;
  }

  /**
   * Processar comando de meta
   * @param {string} userId - ID do usu√°rio
   * @param {Object} analysisResult - Resultado da an√°lise do Gemini
   * @returns {Promise<string>} - Resposta formatada
   */
  async process(userId, analysisResult) {
    try {
      const { acao, tipo } = analysisResult;
      
      switch (acao?.toLowerCase()) {
        case 'criar_meta':
        case 'nova_meta':
          return await this.createGoal(userId, analysisResult);
          
        case 'listar_metas':
        case 'minhas_metas':
        case 'ver_metas':
          return await this.listGoals(userId, analysisResult);
          
        case 'progresso_meta':
        case 'status_meta':
          return await this.getGoalProgress(userId, analysisResult);
          
        case 'atualizar_meta':
        case 'adicionar_progresso':
          return await this.updateGoalProgress(userId, analysisResult);
          
        case 'deletar_meta':
        case 'remover_meta':
          return await this.deleteGoal(userId, analysisResult);
          
        case 'categorias_meta':
        case 'tipos_meta':
          return await this.listGoalCategories(analysisResult);
          
        case 'estatisticas_metas':
        case 'resumo_metas':
          return await this.getGoalStats(userId);
          
        default:
          return this.getHelpMessage();
      }
    } catch (error) {
      return this.handleError(error, userId, analysisResult, 'meta');
    }
  }

  /**
   * Criar nova meta
   * @param {string} userId - ID do usu√°rio
   * @param {Object} analysisResult - Dados da meta
   * @returns {Promise<string>} - Resposta formatada
   */
  async createGoal(userId, analysisResult) {
    try {
      const validation = this.validateGoalInput(analysisResult);
      if (!validation.isValid) {
        return ResponseFormatter.formatValidationMessage(validation.errors);
      }

      const {
        titulo,
        descricao,
        valor_meta: targetAmount,
        categoria,
        tipo_meta: goalType,
        data_limite: targetDate,
        prioridade = 'medium'
      } = analysisResult;

      // Processar data limite se fornecida
      let parsedTargetDate = null;
      if (targetDate) {
        parsedTargetDate = DataParser.parseDate(targetDate);
        if (parsedTargetDate < new Date()) {
          return '‚ùå A data limite n√£o pode ser no passado. Escolha uma data futura.';
        }
      }

      const goalData = {
        title: titulo,
        description: descricao,
        targetAmount: parseFloat(targetAmount),
        category: categoria,
        goalType: goalType,
        targetDate: parsedTargetDate,
        priority: prioridade
      };

      const goal = await this.goalModel.createGoal(userId, goalData);

      console.log('üéØ Meta criada:', goal);
      this.logGoalAction('Meta criada', userId, goal);

      return this.formatGoalCreatedMessage(goal);
    } catch (error) {
      console.error('‚ùå Erro ao criar meta:', error);
      return '‚ùå Erro ao criar meta. Tente novamente.';
    }
  }

  /**
   * Listar metas do usu√°rio
   * @param {string} userId - ID do usu√°rio
   * @param {Object} analysisResult - Filtros opcionais
   * @returns {Promise<string>} - Lista formatada de metas
   */
  async listGoals(userId, analysisResult) {
    try {
      const { status = 'active', categoria } = analysisResult;
      
      let goals;
      if (categoria) {
        goals = await this.goalModel.getGoalsByCategory(userId, categoria, status);
      } else {
        goals = await this.goalModel.getUserGoals(userId, status);
      }

      if (!goals || goals.length === 0) {
        return this.getNoGoalsMessage(status, categoria);
      }

      return this.formatGoalsList(goals, status);
    } catch (error) {
      console.error('‚ùå Erro ao listar metas:', error);
      return '‚ùå Erro ao buscar suas metas. Tente novamente.';
    }
  }

  /**
   * Obter progresso de uma meta espec√≠fica
   * @param {string} userId - ID do usu√°rio
   * @param {Object} analysisResult - Dados da consulta
   * @returns {Promise<string>} - Progresso formatado
   */
  async getGoalProgress(userId, analysisResult) {
    try {
      const { meta_id: goalId, titulo } = analysisResult;
      
      let goal;
      if (goalId) {
        goal = await this.goalModel.getGoalById(goalId, userId);
      } else if (titulo) {
        // Buscar por t√≠tulo
        const goals = await this.goalModel.getUserGoals(userId, 'active');
        goal = goals.find(g => g.title.toLowerCase().includes(titulo.toLowerCase()));
      }

      if (!goal) {
        return '‚ùå Meta n√£o encontrada. Use "minhas metas" para ver todas as suas metas.';
      }

      const history = await this.goalModel.getGoalProgressHistory(goal.id, 5);
      
      return this.formatGoalProgressMessage(goal, history);
    } catch (error) {
      console.error('‚ùå Erro ao buscar progresso da meta:', error);
      return '‚ùå Erro ao buscar progresso da meta. Tente novamente.';
    }
  }

  /**
   * Atualizar progresso de uma meta
   * @param {string} userId - ID do usu√°rio
   * @param {Object} analysisResult - Dados da atualiza√ß√£o
   * @returns {Promise<string>} - Resultado da atualiza√ß√£o
   */
  async updateGoalProgress(userId, analysisResult) {
    try {
      const { meta_id: goalId, titulo, valor, tipo_atualizacao = 'adicionar' } = analysisResult;
      
      let goal;
      if (goalId) {
        goal = await this.goalModel.getGoalById(goalId, userId);
      } else if (titulo) {
        const goals = await this.goalModel.getUserGoals(userId, 'active');
        goal = goals.find(g => g.title.toLowerCase().includes(titulo.toLowerCase()));
      }

      if (!goal) {
        return '‚ùå Meta n√£o encontrada. Use "minhas metas" para ver todas as suas metas.';
      }

      if (goal.status !== 'active') {
        return '‚ùå N√£o √© poss√≠vel atualizar uma meta que n√£o est√° ativa.';
      }

      const amount = parseFloat(valor);
      if (isNaN(amount) || amount <= 0) {
        return '‚ùå Valor deve ser um n√∫mero positivo.';
      }

      let updatedGoal;
      if (tipo_atualizacao === 'definir') {
        updatedGoal = await this.goalModel.updateGoalProgress(goal.id, amount, 'manual_update');
      } else {
        updatedGoal = await this.goalModel.addToGoalProgress(goal.id, amount, 'manual_update');
      }

      console.log('üéØ Progresso da meta atualizado:', updatedGoal);
      this.logGoalAction('Progresso atualizado', userId, updatedGoal);

      return this.formatGoalUpdateMessage(updatedGoal, amount, tipo_atualizacao);
    } catch (error) {
      console.error('‚ùå Erro ao atualizar progresso da meta:', error);
      return '‚ùå Erro ao atualizar progresso da meta. Tente novamente.';
    }
  }

  /**
   * Deletar uma meta
   * @param {string} userId - ID do usu√°rio
   * @param {Object} analysisResult - Dados da meta a deletar
   * @returns {Promise<string>} - Resultado da opera√ß√£o
   */
  async deleteGoal(userId, analysisResult) {
    try {
      const { meta_id: goalId, titulo, confirmar = false } = analysisResult;
      
      let goal;
      if (goalId) {
        goal = await this.goalModel.getGoalById(goalId, userId);
      } else if (titulo) {
        const goals = await this.goalModel.getUserGoals(userId);
        goal = goals.find(g => g.title.toLowerCase().includes(titulo.toLowerCase()));
      }

      if (!goal) {
        return '‚ùå Meta n√£o encontrada. Use "minhas metas" para ver todas as suas metas.';
      }

      if (!confirmar) {
        return `‚ö†Ô∏è Tem certeza que deseja deletar a meta "${goal.title}"?\n\nPara confirmar, envie: "deletar meta ${goal.title} confirmar"`;
      }

      await this.goalModel.deleteGoal(goal.id, userId);

      console.log('üóëÔ∏è Meta deletada:', goal);
      this.logGoalAction('Meta deletada', userId, goal);

      return `‚úÖ Meta "${goal.title}" foi deletada com sucesso.`;
    } catch (error) {
      console.error('‚ùå Erro ao deletar meta:', error);
      return '‚ùå Erro ao deletar meta. Tente novamente.';
    }
  }

  /**
   * Listar categorias de metas dispon√≠veis
   * @param {Object} analysisResult - Filtros opcionais
   * @returns {Promise<string>} - Lista de categorias
   */
  async listGoalCategories(analysisResult) {
    try {
      const { tipo_meta: goalType } = analysisResult;
      
      const categories = await this.goalModel.getGoalCategories(goalType);
      
      if (!categories || categories.length === 0) {
        return '‚ùå Nenhuma categoria encontrada.';
      }

      return this.formatCategoriesList(categories, goalType);
    } catch (error) {
      console.error('‚ùå Erro ao buscar categorias:', error);
      return '‚ùå Erro ao buscar categorias. Tente novamente.';
    }
  }

  /**
   * Obter estat√≠sticas das metas do usu√°rio
   * @param {string} userId - ID do usu√°rio
   * @returns {Promise<string>} - Estat√≠sticas formatadas
   */
  async getGoalStats(userId) {
    try {
      const stats = await this.goalModel.getUserGoalStats(userId);
      const goalsDueSoon = await this.goalModel.getGoalsDueSoon(userId, 7);
      
      return this.formatGoalStatsMessage(stats, goalsDueSoon);
    } catch (error) {
      console.error('‚ùå Erro ao buscar estat√≠sticas:', error);
      return '‚ùå Erro ao buscar estat√≠sticas das metas. Tente novamente.';
    }
  }

  /**
   * Validar dados de entrada para cria√ß√£o de meta
   * @param {Object} analysisResult - Dados a serem validados
   * @returns {Object} - Resultado da valida√ß√£o
   */
  validateGoalInput(analysisResult) {
    const errors = [];
    const { titulo, valor_meta, categoria, tipo_meta } = analysisResult;
    
    if (!titulo || titulo.trim().length === 0) {
      errors.push('T√≠tulo da meta √© obrigat√≥rio');
    }
    
    if (!valor_meta || parseFloat(valor_meta) <= 0) {
      errors.push('Valor da meta deve ser maior que zero');
    }
    
    if (!categoria || categoria.trim().length === 0) {
      errors.push('Categoria √© obrigat√≥ria');
    }
    
    if (!tipo_meta || !['saving', 'expense_limit', 'income_target', 'investment', 'debt_payment'].includes(tipo_meta)) {
      errors.push('Tipo de meta inv√°lido. Use: saving, expense_limit, income_target, investment ou debt_payment');
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }

  /**
   * Formatar mensagem de meta criada
   * @param {Object} goal - Meta criada
   * @returns {string} - Mensagem formatada
   */
  formatGoalCreatedMessage(goal) {
    const targetDateText = goal.target_date ? 
      `\nüìÖ **Data limite:** ${moment(goal.target_date).format('DD/MM/YYYY')}` : '';
    
    const typeEmoji = this.getGoalTypeEmoji(goal.goal_type);
    
    return `‚úÖ **Meta criada com sucesso!**\n\n` +
           `${typeEmoji} **${goal.title}**\n` +
           `üí∞ **Valor:** R$ ${parseFloat(goal.target_amount).toFixed(2)}\n` +
           `üìÇ **Categoria:** ${goal.category}\n` +
           `üìä **Progresso:** R$ 0,00 (0%)${targetDateText}\n\n` +
           `üí° *Dica: Suas transa√ß√µes ser√£o automaticamente vinculadas a esta meta quando poss√≠vel.*`;
  }

  /**
   * Formatar lista de metas
   * @param {Array} goals - Lista de metas
   * @param {string} status - Status filtrado
   * @returns {string} - Lista formatada
   */
  formatGoalsList(goals, status) {
    const statusEmoji = {
      'active': 'üéØ',
      'completed': '‚úÖ',
      'paused': '‚è∏Ô∏è',
      'cancelled': '‚ùå'
    };
    
    let message = `${statusEmoji[status] || 'üìã'} **Suas metas ${status === 'active' ? 'ativas' : status}:**\n\n`;
    
    goals.forEach((goal, index) => {
      const progress = parseFloat(goal.progress_percentage || 0);
      const progressBar = this.createProgressBar(progress);
      const typeEmoji = this.getGoalTypeEmoji(goal.goal_type);
      
      const daysRemaining = goal.days_remaining ? 
        `\n‚è∞ ${goal.days_remaining} dias restantes` : '';
      
      message += `${index + 1}. ${typeEmoji} **${goal.title}**\n` +
                 `üí∞ R$ ${parseFloat(goal.current_amount).toFixed(2)} / R$ ${parseFloat(goal.target_amount).toFixed(2)}\n` +
                 `${progressBar} ${progress.toFixed(1)}%${daysRemaining}\n\n`;
    });
    
    message += `üí° *Para ver detalhes de uma meta, use: "progresso meta [nome da meta]"*`;
    
    return message;
  }

  /**
   * Formatar mensagem de progresso da meta
   * @param {Object} goal - Meta
   * @param {Array} history - Hist√≥rico de progresso
   * @returns {string} - Mensagem formatada
   */
  formatGoalProgressMessage(goal, history) {
    const progress = parseFloat(goal.progress_percentage || 0);
    const progressBar = this.createProgressBar(progress);
    const typeEmoji = this.getGoalTypeEmoji(goal.goal_type);
    
    const remaining = parseFloat(goal.target_amount) - parseFloat(goal.current_amount);
    const daysText = goal.days_remaining ? 
      `\n‚è∞ **Prazo:** ${goal.days_remaining} dias restantes` : '';
    
    let message = `${typeEmoji} **${goal.title}**\n\n` +
                  `üí∞ **Progresso:** R$ ${parseFloat(goal.current_amount).toFixed(2)} / R$ ${parseFloat(goal.target_amount).toFixed(2)}\n` +
                  `${progressBar} **${progress.toFixed(1)}%**\n` +
                  `üí∏ **Faltam:** R$ ${remaining.toFixed(2)}${daysText}\n\n`;
    
    if (goal.description) {
      message += `üìù **Descri√ß√£o:** ${goal.description}\n\n`;
    }
    
    if (history && history.length > 0) {
      message += `üìà **√öltimas atualiza√ß√µes:**\n`;
      history.slice(0, 3).forEach(entry => {
        const date = moment(entry.created_at).format('DD/MM');
        const changeText = entry.change_amount > 0 ? 
          `+R$ ${entry.change_amount.toFixed(2)}` : 
          `R$ ${entry.change_amount.toFixed(2)}`;
        message += `‚Ä¢ ${date}: ${changeText}\n`;
      });
    }
    
    return message;
  }

  /**
   * Formatar mensagem de atualiza√ß√£o de meta
   * @param {Object} goal - Meta atualizada
   * @param {number} amount - Valor adicionado/definido
   * @param {string} type - Tipo de atualiza√ß√£o
   * @returns {string} - Mensagem formatada
   */
  formatGoalUpdateMessage(goal, amount, type) {
    const progress = (parseFloat(goal.current_amount) / parseFloat(goal.target_amount)) * 100;
    const progressBar = this.createProgressBar(progress);
    
    const actionText = type === 'definir' ? 
      `definido para R$ ${amount.toFixed(2)}` : 
      `adicionado R$ ${amount.toFixed(2)}`;
    
    let message = `‚úÖ **Progresso ${actionText}!**\n\n` +
                  `üéØ **${goal.title}**\n` +
                  `üí∞ R$ ${parseFloat(goal.current_amount).toFixed(2)} / R$ ${parseFloat(goal.target_amount).toFixed(2)}\n` +
                  `${progressBar} **${progress.toFixed(1)}%**\n\n`;
    
    if (progress >= 100) {
      message += `üéâ **PARAB√âNS! Meta atingida!** üéâ\n\n` +
                 `Voc√™ conseguiu alcan√ßar sua meta "${goal.title}"! üèÜ`;
    } else {
      const remaining = parseFloat(goal.target_amount) - parseFloat(goal.current_amount);
      message += `üí™ Continue assim! Faltam apenas R$ ${remaining.toFixed(2)} para atingir sua meta.`;
    }
    
    return message;
  }

  /**
   * Formatar lista de categorias
   * @param {Array} categories - Lista de categorias
   * @param {string} goalType - Tipo de meta filtrado
   * @returns {string} - Lista formatada
   */
  formatCategoriesList(categories, goalType) {
    const typeText = goalType ? ` para ${goalType}` : '';
    let message = `üìÇ **Categorias de metas${typeText}:**\n\n`;
    
    const groupedByType = {};
    categories.forEach(cat => {
      if (!groupedByType[cat.goal_type]) {
        groupedByType[cat.goal_type] = [];
      }
      groupedByType[cat.goal_type].push(cat);
    });
    
    Object.keys(groupedByType).forEach(type => {
      const typeEmoji = this.getGoalTypeEmoji(type);
      const typeName = this.getGoalTypeName(type);
      message += `${typeEmoji} **${typeName}:**\n`;
      
      groupedByType[type].forEach(cat => {
        message += `‚Ä¢ ${cat.icon || 'üìå'} ${cat.name}\n`;
      });
      message += '\n';
    });
    
    return message;
  }

  /**
   * Formatar estat√≠sticas das metas
   * @param {Object} stats - Estat√≠sticas
   * @param {Array} goalsDueSoon - Metas pr√≥ximas do vencimento
   * @returns {string} - Estat√≠sticas formatadas
   */
  formatGoalStatsMessage(stats, goalsDueSoon) {
    let message = `üìä **Resumo das suas metas:**\n\n` +
                  `üìà **Total:** ${stats.total} metas\n` +
                  `üéØ **Ativas:** ${stats.active}\n` +
                  `‚úÖ **Conclu√≠das:** ${stats.completed}\n` +
                  `‚è∏Ô∏è **Pausadas:** ${stats.paused}\n\n` +
                  `üí∞ **Valor total das metas:** R$ ${stats.totalTargetAmount.toFixed(2)}\n` +
                  `üí∏ **Progresso total:** R$ ${stats.totalCurrentAmount.toFixed(2)}\n`;
    
    const overallProgress = stats.totalTargetAmount > 0 ? 
      (stats.totalCurrentAmount / stats.totalTargetAmount) * 100 : 0;
    const progressBar = this.createProgressBar(overallProgress);
    message += `${progressBar} **${overallProgress.toFixed(1)}%**\n\n`;
    
    if (goalsDueSoon && goalsDueSoon.length > 0) {
      message += `‚ö†Ô∏è **Metas pr√≥ximas do vencimento:**\n`;
      goalsDueSoon.forEach(goal => {
        message += `‚Ä¢ ${goal.title} (${goal.days_remaining} dias)\n`;
      });
      message += '\n';
    }
    
    return message;
  }

  /**
   * Criar barra de progresso visual
   * @param {number} percentage - Percentual (0-100)
   * @returns {string} - Barra de progresso
   */
  createProgressBar(percentage) {
    const filled = Math.round(percentage / 10);
    const empty = 10 - filled;
    return '‚ñì'.repeat(filled) + '‚ñë'.repeat(empty);
  }

  /**
   * Obter emoji para tipo de meta
   * @param {string} goalType - Tipo da meta
   * @returns {string} - Emoji correspondente
   */
  getGoalTypeEmoji(goalType) {
    const emojis = {
      'saving': 'üí∞',
      'expense_limit': 'üö´',
      'income_target': 'üìà',
      'investment': 'üìä',
      'debt_payment': 'üí≥'
    };
    return emojis[goalType] || 'üéØ';
  }

  /**
   * Obter nome amig√°vel para tipo de meta
   * @param {string} goalType - Tipo da meta
   * @returns {string} - Nome amig√°vel
   */
  getGoalTypeName(goalType) {
    const names = {
      'saving': 'Economia',
      'expense_limit': 'Limite de Gastos',
      'income_target': 'Meta de Renda',
      'investment': 'Investimento',
      'debt_payment': 'Pagamento de D√≠vida'
    };
    return names[goalType] || 'Meta';
  }

  /**
   * Mensagem quando n√£o h√° metas
   * @param {string} status - Status filtrado
   * @param {string} category - Categoria filtrada
   * @returns {string} - Mensagem
   */
  getNoGoalsMessage(status, category) {
    const statusText = status === 'active' ? 'ativas' : status;
    const categoryText = category ? ` na categoria "${category}"` : '';
    
    return `üì≠ Voc√™ n√£o tem metas ${statusText}${categoryText}.\n\n` +
           `üí° Para criar uma nova meta, envie algo como:\n` +
           `"Criar meta economizar R$ 1000 para viagem at√© dezembro"`;
  }

  /**
   * Mensagem de ajuda
   * @returns {string} - Mensagem de ajuda
   */
  getHelpMessage() {
    return `üéØ **Comandos de Metas Dispon√≠veis:**\n\n` +
           `üìù **Criar meta:**\n` +
           `‚Ä¢ "Criar meta economizar R$ 1000 para viagem"\n` +
           `‚Ä¢ "Nova meta limite gastos alimenta√ß√£o R$ 500"\n\n` +
           `üìã **Ver metas:**\n` +
           `‚Ä¢ "Minhas metas"\n` +
           `‚Ä¢ "Metas ativas"\n` +
           `‚Ä¢ "Metas conclu√≠das"\n\n` +
           `üìä **Progresso:**\n` +
           `‚Ä¢ "Progresso meta viagem"\n` +
           `‚Ä¢ "Status meta casa pr√≥pria"\n\n` +
           `‚úèÔ∏è **Atualizar:**\n` +
           `‚Ä¢ "Adicionar R$ 100 meta viagem"\n` +
           `‚Ä¢ "Definir progresso meta R$ 500"\n\n` +
           `üóëÔ∏è **Deletar:**\n` +
           `‚Ä¢ "Deletar meta viagem"\n\n` +
           `üìÇ **Outros:**\n` +
           `‚Ä¢ "Categorias de metas"\n` +
           `‚Ä¢ "Resumo metas"`;
  }

  /**
   * Log de a√ß√£o relacionada a meta
   * @param {string} action - A√ß√£o realizada
   * @param {string} userId - ID do usu√°rio
   * @param {Object} goal - Meta
   */
  logGoalAction(action, userId, goal) {
    console.log(`üéØ ${action}:`, {
      userId,
      goalId: goal.id,
      title: goal.title,
      targetAmount: goal.target_amount,
      currentAmount: goal.current_amount
    });
  }

  /**
   * Tratar erros espec√≠ficos de metas
   * @param {Error} error - Erro ocorrido
   * @param {string} userId - ID do usu√°rio
   * @param {Object} analysisResult - Dados da an√°lise
   * @param {string} action - A√ß√£o que causou o erro
   * @returns {string} - Mensagem de erro
   */
  handleError(error, userId, analysisResult, action) {
    console.error(`‚ùå Erro ao processar ${action}:`, error);
    
    if (error.message.includes('n√£o encontrada')) {
      return error.message;
    }
    
    if (error.message.includes('valida√ß√£o')) {
      return `‚ùå Dados inv√°lidos: ${error.message}`;
    }
    
    return `‚ùå Erro ao processar ${action}. Tente novamente ou use "ajuda metas" para ver os comandos dispon√≠veis.`;
  }
}

module.exports = GoalHandler;